

<!DOCTYPE html>
<html lang="en" >

<head>

  <meta charset="UTF-8">
  
<link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
<meta name="apple-mobile-web-app-title" content="CodePen">

<link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />

<link rel="mask-icon" type="" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />


  <title>CodePen - CSS Fixed Conic Fill</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
  
<style>
article {
  /*  leverage cascade for cross-browser gradients  */
  background: radial-gradient(
    hsl(100 100% 60%), 
    hsl(200 100% 60%) 
  ) fixed;
  background: conic-gradient(
    hsl(100 100% 60%), 
    hsl(200 100% 60%), 
    hsl(100 100% 60%) 
  ) fixed;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
} 

body {
  background: hsl(204 100% 5%);
/*   background: conic-gradient(
    hsl(100 100% 60%), 
    hsl(200 100% 60%),
    hsl(100 100% 60%)
  ) fixed; */
  color: white;
  min-block-size: 200vh;
  min-inline-size: 100%;
  padding: 5vmin;
  box-sizing: border-box;
  display: grid;
  place-content: center;
  font-family: system-ui;
  font-size: min(200%, 5vmin);
}

h1, p, body {
  margin: 0;
}

h1 {
  font-size: 10vmin;
  line-height: 1.1;
  max-inline-size: 15ch;
  margin: auto;
}

p {
  font-family: "Dank Mono", ui-monospace, monospace;
  margin-top: 1ch;
  line-height: 1.35;
  max-inline-size: 40ch;
  margin: auto;
}

html {
  block-size: 100%;
  inline-size: 100%;
  text-align: center;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>


</head>

<body translate="no" >
  <article>
  <h1> Я ЛЮБЛЮ ПИИСЬКИ (МАКАРЕНУ ТОЖЕ)</h1>
  <p>Док-ва приколов по алгосам 2.

Теория

1. Док-во эквивалентности определений дерева:
Определение 1: Дерево - связный неориентированный граф без простых циклов.
Определение 2: Дерево - Неориентированный граф с n вершинами и n-1 ребром.

Докажем, что всякий граф подходящий под Определение 1, подходит и под Определение 2

Для начала докажем промежуточный факт:
В графе из О1 всегда найдется висячая вершина.

Пусть это не так. Тогда все вершины имеют степень по крайней мере 2. Тогда будем "гулять по графу", каждый раз выбирая случайную вершину (кроме той, из которой мы пришли) среди соседей текущих. 
Тогда мы будем бесконечно гулять по графу, т.е в какой-то момент посетим какую-то вершину дважды, т.е в графе найдется цикл.

Значит, в графе из О1 действительно всегда найдется висячая вершина.

Тогда будем по одной удалять из графа висячие вершины вместе с ребром, выходящим из них. Очевидно, связность не нарушится и циклов не появится. Тогда, после удаления n-1 вершины у нас останется одна вершин и соответственно 0 ребер. Т.е изначально в графе было n-1 ребро и n вершин.

Теперь докажем, что граф, подходящий под О2 подходит и под О1.

Пусть в графе, подходящем под О2 есть один или несколько циклов.
Будем удалять по одну ребру (u, v) из цикла, пока таковые есть. Заметим, что связность тогда не нарушится, т.к любой путь a -> b, содержащий это ребро, является не единственным путем между a и b, т.к от u до v можно добраться, двигаясь по циклу. Тогда мы удалили хотя бы одно ребро и получили граф, подходящий под О1 и имеющий <= n-2 ребер. Такого быть не может.

ЧТД.

2. Алгоритм нахождения диаметра дерева
Амир спс!!!
Давайте осознаем, что диаметр - это расстояние между двумя листами. 
Предположим, что есть диаметр, один из концов которого - не лист. Пусть это конец b. Тогда закрасим ребра диаметра. От b исходило хотя бы два ребра, а покрашено от нее только одно. Пусть непокрашенное ведет в u. Давайте посмотрим на расстояние между u и другим концом диаметра. Оно равно диаметру + 1(т.к. ребро b-u не было использовано). Т. е. это был не диаметр.

Давайте посмотрим на дерево обхода DFS. Докажем, что нет ребер между двумя вершинами из разных поддеревьев некоторой вершины x. Если такое ребро u-v есть, то пусть dfs(v) был запущен раньше, чем dfs(u). Тогда при более раннем запуске мы пошли из u -> v, тогда они в одном поддереве.

Поиск диаметра свелся к поиску некоторой вершины v, такой, что сумма глубин ее двух самых глубоких поддеревьев максимальна. В одном из этих поддеревьев точно лежит самый глубокий лист всего дерева - если нет, то возьмем расстояние от v до этого самого глубокого листа и любое из расстояний до самой глубокой вершины поддерева с корнем в v (пусть вершина u). Путь из u в самый глубокий лист и в u по ребрам не пересекаются, т.к. этот лист не в поддереве v. Путь из u до самого глубокого листа больше того диаметра, который мы нашли, противоречие.
Значит, один из концов диаметра - самый глубокий лист, который можно найти один дфсом. Второй конец диаметра умеем искать, взяв вершину, которая максимально удалена от глубочайшего листа.

3. Доказательство единственности центра (центров) диаметров.
Пусть найдутся 2 диаметра, центры которых не совпадают.
Тогда, ввиду того, что граф связный, между ними есть путь. Если 2 диаметра не пересекаются, возьмём половину диаметра исходящего из одного центра и половину исходящего из другого, объединим их и получим путь, который длиннее диаметров. Такого быть не может. 




|================================================|

А. Выбор вершин дерева

Пусть dp[i][0] - максимальное кол-во вершин, которое можно выбрать в поддереве i, не используя саму вершину i,
      dp[i][1] - максимальное кол-во вершин, которое можно выбрать в поддереве i, задействуя вершину i.
      
Начальные значения:
dp от всех висячих вершин = {0, 1}.

Пересчет:
dp[i][0] = сумма max(dp[j][0], dp[j][1]) для всех j таких, что j - прямой ребенок i.
dp[i][0] = 1 + сумма dp[j][0] для всех j таких, что j - прямой ребенок i.

Где лежит ответ:
max(dp[root][0], dp[root][1])

Порядок действий:
Считываем граф, находим корень root. Запускаем дфс из root. 
В теле дфса, при входе в вершину i инициализируем dp[i] как {0, 1};
Далее проходимся циклом по всем детям i, запускаем из них дфс. После чего dp[i][0] += max(dp[j][1], dp[j][0]), dp[i][1] += dp[j][0]

Почему дп работает:
Если дп для всех детей вершины i посчитано верно, то, т.к не существует ребра между двумя поддеревьями никаких двух детей i,
dp[i][0] будет соответствовать формуле, т.к по определению этого дп, мы не можем взять вершину i, а поддеревья не конфликтуют между собой.
dp[i][1] будет соответствовать формуле, т.к взяв вершину i, мы уже не можем взять никого из ее детей, а поддеревья не конфликтуют между собой

Для листов, очевидно, дп посчитано верно. 
Значит, все работает.

Мой код:
#include <bits/stdc++.h>

using namespace std;

#define INF (int)(2e9)
#define int long long
#define LL0 (int)(0)

vector <vector <int> > g;
vector <vector <int> > dp;
int root;

void count_dp(int curr) {
    dp[curr][1] = 1;
    for (auto to : g[curr]) {
        count_dp(to);
        dp[curr][0] += max(dp[to][1], dp[to][0]);
        dp[curr][1] += dp[to][0];
    }
}

signed main() {
    int n; cin >> n;

    dp.resize(n, vector <int> (2));
    g.resize(n);

    for (int i = 0; i < n; i++) {
        int a; cin >> a; a--;
        if (a == -1) {root = i; continue;}

        g[a].push_back(i);
    }

    count_dp(root);
    cout << max(dp[root][0], dp[root][1]);
}

|================================================|

B. Простые пути
Я не сдал, док-ва не будет, если его кто-то не предоставит.

|================================================|

C. Рога и Копыта

Заметим, что порядок, с которым выбираются подчиненные не важен, имеет роль только тот факт, что у подчиненных нет своих подчиненных.
Тогда задачу можно переформулировать:
Построим на сотрудниках дерево по селдующему правилу: между сотрудниками (a, b) есть ребро если a является прямым начальником b.

Процесс идет пока все сотрудники не уволятся.
Каждый шаг выбирается какая-то висячая вершина дерева, после чего из нее производится подъем по дереву вверх, где каждому сотруднику, начиная с нее прибавляется на 1 рубль больше, чем предыдущему, а она сама получает 1 рубль. Далее вершина удаляется

Заметим, что каждый сотрудник получает деньги только с заказов из его поддерева.

Пусть dp[i] - кол-во денег, которое получит i-тый сотрудник.
sz[i] - размер поддерева i-того сотрудника.

Начальные значения:
dp и sz от всех изначально висящих вершин = 1;  

Переход:
dp[i] = 1 + сумма по всем dp[j] + sz[j], где j - ребенок i.
sz[i] = 1 + сумма по всем sz[j], где j - ребенок i.

Где лежит ответ:
Ответ для i-того сотрудника - dp[i].

Порядок действий:
Считываем граф, запускаем дфс от корня.
В теле дфса устанавливаем начальные значения: sz[curr] = 1, dp[curr] = 1
Далее для всех детей to вершины curr запускаем дфс и обновляем значения: dp[curr] += dp[to] + sz[to]. sz[curr] += sz[to].

Почему дп работает:
Размер поддерева вершины i по определению есть кол-во вершин, предком которых является i. Значит, sz, очевидно, посчитан верно.

Пусть dp для всех детей вершины i посчитан верно. Тогда заметим, что с каждого заказа из поддерева j, сотрудник i получил на одну монету больше, чем j, т.е в сумме с заказов поддерева j он получил ровно dp[j] + sz[j]. 
Значит, т.к еще один заказ будет выполнять лично сотрудник i, dp[i] действительно соответствует представленной выше формуле.

Начальные значения, очевидно, посчитаны верно, т.к каждая висячая вершина выполняет один заказ и отваливается.

Значит, дп работает. ЧТД.

Мой код:
#include <iostream>
#include <vector>

using namespace std;

#define int long long
#define inf (int)(2e18)
#define mod (int)(1e9 + 7)

vector <int> dp;
vector <vector <int> > g;
vector <int> sz;

void dfs(int curr) {
    dp[curr] = 1, sz[curr] = 1;
    for (auto to : g[curr]) {
        dfs(to);
        sz[curr] += sz[to];
        dp[curr] += dp[to] + sz[to];
    }
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n; cin >> n;
    g.resize(n); dp.resize(n); sz.resize(n);

    for (int i = 1; i < n; i++) {
        int a; cin >> a; a--;
        g[a].push_back(i);
    }

    dfs(0);
    for (auto i : dp) cout << i << " ";
}

|================================================|

D. Новогодняя премия
Я не сдал, док-ва не будет, если кто-то не предоставит.

|================================================|

Е. Центр сети

Порядок действий:
Запустим дфс/бфс из проивзольной вершины, найдем самую удаленную из достижимых вершину.
Далее запустим дфс/бфс из нее, запоминая предка в пути. Восстановим путь до самой удаленной из достижимых вершины. 
Если путь имеет нечетную длину выводим два центральных элемента, если путь имеет четную длину - один центральный элемент.

Док-во:
Все диаметры имеют общий центр(-ы) (см. док-во выше, если я его туда добавил)
Алгоритм находит диаметр корректно (см. док-во выше, если я его туда добавил), значит, остается только вывести центры.

Мой код:
#include <bits/stdc++.h>

using namespace std;

#define INF (int)(2e9)
#define int long long
#define LL0 (int)(0)

pair <vector <int>, vector <int> > bfs(const vector <vector <int> >& g, int n, int start) {
    vector <int> prev(n, -1), ans(n, INF); ans[start] = 0;

    queue <int> q; q.push(start);
    while (!q.empty()) {
        auto curr = q.front(); q.pop();

        for (auto to : g[curr]) {
            if (ans[to] > ans[curr] + 1) {
                prev[to] = curr; ans[to] = ans[curr] + 1; q.push(to);
            }
        }
    }

    return {ans, prev};
}

vector <int> get_path(int from, const vector <int>& prev) {
    vector <int> ans;
    while (from != -1) {
        ans.push_back(from);
        from = prev[from];
    }

    return ans;
}

signed main() {
    int n; cin >> n;

    vector <vector <int> > g(n);

    for (int i = 0; i < n-1; i++) {
        int a; cin >> a; a--;
        g[a].push_back(i + 1);
        g[i + 1].push_back(a);
    }

    auto q = bfs(g, n, 0).first;

    int mx = 0;
    for (int i = 0; i < n; i++) {
        if (q[i] != INF && q[i] > q[mx]) {
            mx = i;
        }
    }

    auto r = bfs(g, n, mx);

    mx = 0;
    for (int i = 0; i < n; i++) {
        if (r.first[i] != INF && r.first[i] > r.first[mx]) {
            mx = i;
        }
    }

    auto path = get_path(mx, r.second);

    vector <int> ans;
    if (path.size() % 2) {
        ans = {path[path.size() / 2]};
    }
    else {
        ans = {path[path.size() / 2 - 1], path[path.size() / 2]};
    }

    sort(ans.begin(), ans.end());
    for (auto i : ans) cout << i+1 << " ";
}



|================================================|

F. Канат в лабиринте

Мысленно построим граф на клетках, где ребро (a, b) существует тогда и только тогда, когда клетки a и b пустые и имеют общую сторону. 
Тогда из условия граф - дерево.

Порядок действий:
Запускаем дфс/бфс из произвольной пустой клетки. Находим максимально удаленную достижимую пустую клетку. Запускаем дфс/бфс из этой вершины, выводим расстояние от нее до максимально удаленной от нее достижимой пустой клетки.
В теле самого дфса пытаемся пойти на клетку влево, вверх, вправо, вниз. Если получается и клетка не занята - идем.

Док-во:
Заметим, что дабы выполнить требуемое в задаче условие для выхода, в худшем случае, нужно будет пройти наибольшее расстояние в таблице, т.е по диаметру.
Очевидно, ребра из клетки могут идти только в соседние по стороне, т.е дфс работает.
Алгоритм поиска диаметра работает. (см. док-во выше, если я его туда добавил).

Значит, все будет посчитано правильно.
Чтд.

Мой код (по размерам далеко не самый оптимальный):
#include <bits/stdc++.h>

using namespace std;

#define INF (int)(2e9)
#define int long long
#define LL0 (int)(0)

pair <vector <int>, vector <int> > bfs(const vector <vector <int> >& g, int n, int start) {
    vector <int> prev(n, -1), ans(n, INF); ans[start] = 0;

    queue <int> q; q.push(start);
    while (!q.empty()) {
        auto curr = q.front(); q.pop();

        for (auto to : g[curr]) {
            if (ans[to] > ans[curr] + 1) {
                prev[to] = curr; ans[to] = ans[curr] + 1; q.push(to);
            }
        }
    }

    return {ans, prev};
}

signed main() {
    int n, m; cin >> n >> m; swap(n, m);

    vector <vector <char> > v(n, vector <char> (m));
    for (auto &i : v) for (auto &j : i) cin >> j;

    vector <vector <int> > g(n*m);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (v[i][j] == '#') continue;

            if (i + 1 < n && v[i+1][j] != '#') {
                g[i*m + j].push_back((i+1)*m + j);
                g[(i+1)*m + j].push_back(i*m + j);
            }

            if (j + 1 < m && v[i][j+1] != '#') {
                g[i*m + j].push_back(i*m + j + 1);
                g[i*m + j + 1].push_back(i*m + j);
            }
        }
    }

    int start = 0;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < m; j++) 
            if (v[i][j] == '.') 
                start = i*m + j;

    auto q = bfs(g, n*m, start).first;

    int mx = start;
    for (int i = 0; i < n*m; i++) {
        if (q[i] != INF && q[i] > q[mx]) {
            mx = i;
        }
    }

    auto r = bfs(g, n*m, mx);

    mx = start;
    for (int i = 0; i < n*m; i++) {
        if (r.first[i] != INF && r.first[i] > r.first[mx]) {
            mx = i;
        }
    }

    cout << r.first[mx];
}

|================================================|

G. Забавная игра (АХАХАХАХ)

Здесь я совмещу доказательство и формулировку порядка действий.

Назовем проигрышной такую позицию, что начиная в ней, террорист заведомо проигрывает при правильной игре соперника.
Назовем выигрышной такую позицию, что начиная в ней, террорист независимо от игры противника может одержать победу при правильных действиях.

Пусть для каждого ребенка j вершины i известно, является ли позиция проигрышной или выигрышной.
Тогда рассмотрим два случая:

1. Среди всех детей j вершины i найдется хотя бы одна проигрышная позиция.
Тогда позиция i является выигрышной, т.к после того, как террорист полетит в вершину j, его оппонент окажется в проигрышной позиции.

2. Среди детей j вершины i не нашлось не одной проигрышной позиции.
Тогда либо вершина i является висячей (из ее единственного соседа - родителя - мы только что прилетели), либо все ее дети являются выигрышными позициями.
Тогда либо i является проигрышной из-за того, что из нее нельзя совершить ход, либо она является проигрышной из-за того, что как бы не пошел терроросит, его оппонент окажется в выигрышной вершине.

Заметим, что в таком случае любая вершина однозначно определяется как проигрышная и выигрышная.
Запустим дфс из стартовой вершины. Для каждого из ее сыновей запустим дфс. Если после цикла мы нашли проигрышную вершину среди ее детей, присваиваем позиции значение выигрышной. Если нет - проигрышной.
Если стартовая вершина оказалось выигрышной - перебираем ее сыновей, находим наименьшее j среди них, такое, что позиция j - проигрышная. Выводим, что первый игрок выигрывает, вылетая в j.
Если стартовая вершина проигрышная - выводим, что первый игрок проигрывает.

Мой код (красивое):
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

#define int long long
#define inf (int)(2e18)
#define mod (int)(1e9 + 7)

#define WINNING true
#define LOSING false

vector <vector <int> > g;
vector <bool> position;
vector <bool> used;

void dfs(int curr) {
    used[curr] = true;

    vector <bool> neighbours;
    for (auto to : g[curr]) {
        if (!used[to]) {
            dfs(to);
            neighbours.push_back(position[to]);
        }
    }

    for (auto i : neighbours) {
        if (i == LOSING) {
            position[curr] = WINNING;
            return;
        }
    }

    position[curr] = LOSING;
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, k; cin >> n >> k; k--;

    g.resize(n); position.resize(n); used.resize(n);

    for (int i = 0; i < n-1; i++) {
        int a, b; cin >> a >> b; a--; b--;

        g[a].push_back(b); g[b].push_back(a);
    }

    dfs(k);

    if (position[k] == LOSING) {
        cout << "First player loses";
    }
    else {
        cout << "First player wins flying to airport ";
        int ans = inf;
        for (auto to : g[k]) {
            if (position[to] == LOSING) {
                ans = min(ans, to);
            }
        }
        cout << ans + 1;
    }
}

|================================================|

H. Здоровье графа

Заметим, что т.к граф неориентирован, ацикличен и необязательно связен, он состоит из одного или нескольких непересекающихся деревьев.

Порядок действий: 
Заводим массив sz (sz[i] - размер поддерева вершины i),
               depth (depth[i] - расстояние от корня до вершины i, aka глубина)
               root (root[i] - корень дерева, в котором находится вершина i)
               
Считываем граф, запускаем dfs(i, parent = -1 _depth = 0, _root = u) из произвольной вершины i.
В дфсе инициализируем sz[i] = 1, depth = _depth, root[i] = _root. Для каждого ребенка (соседа, не являющегося родителем) j вершины i запускаем dfs(j, i, _depth + 1, _root). Прибавляем к sz[i] число sz[j].

Далее считываем запросы.
Берем концы a и b ребра. Если точка b находится глубже a - меняем их местами. Далее выводим sz[b] * (sz[root[a]] - sz[b]). 

Док-во:
Так как большая часть решения - простой предподсчет глубин, доказать нужно лишь правильность формулы.
Поступим следующим образом: временно сотрем ребро (a, b). Дерево, в котором находились a и b разобьется на две компоненты связности (это следует из единтсвенности пути между а и b). Заметим, что любой путь, проходящий через ребро (a, b) начинается в одной из этих компонент и заканчивается в другой. Тогда кол-во путей - размер первой компоненты * размер второй компонент, т.е в точности то, что есть формула. Свапание в данном случае нужно для того, чтобы граф распался на компоненты (Так как мы считаем только размеры поддеревьев, если depth[a] > depth[b], поддерево вершины b, размер которого лежит в sz[b], будет содержать в себе вершину а, что недопустимо). 

ЧТД.

Мой код:
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

#define int long long
#define inf (int)(2e18)
#define mod (int)(1e9 + 7)

vector <vector <int> > g;
vector <int> sz;
vector <int> depth;
vector <int> root;

void dfs(int curr, int parent, int _depth, int _root) {
    sz[curr] = 1, depth[curr] = _depth; root[curr] = _root;
    for (auto to : g[curr]) {
        if (to != parent) {
            dfs(to, curr, _depth + 1, _root);
            sz[curr] += sz[to];
        }
    }
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, m; cin >> n >> m;

    g.resize(n); sz.resize(n); depth.resize(n); root.resize(n);

    vector <pair <int, int> > edges;
    for (int i = 0; i < m; i++) {
        int a, b; cin >> a >> b; a--; b--;

        edges.emplace_back(a, b);
        g[a].push_back(b); g[b].push_back(a);
    }

    for (int i = 0; i < n; i++) {
        if (!sz[i]) {
            dfs(i, -1, 0, i);
        }
    }

    int q; cin >> q;
    while (q--) {
        int i; cin >> i; i--;
        auto [a, b] = edges[i];

        if (depth[a] > depth[b]) {
            swap(a, b);
        }

        cout << (sz[root[a]] - sz[b]) * (sz[b]) << "\n";
    }
}

|================================================|

I. Ancestor. Предок.

Порядок действий:
Считываем граф. Из корня запускаем дфс.
В самом дфсе, помимо обычных процедур, для вершины i посчитаем значения tin[i] и tout[i] - время входа и выхода соответственно.
При входе tin[i] = T++;
При выходе tout[i] = T++;

После этого ответим на запросы.
Ответом на вопрос (a, b) будет истина, если tin[a] <= tin[b] и tout[a] >= tout[b].

Док-во:
Заметим, что так как выход из дфса от i-той вершины производится после выхода из всех ее потомков, если a - предок b, tout[a] >= tout[b]. 
Заметим, что дабы попасть в вершину j, нужно для начала попасть во всех ее предков. Значит, если a - предок b, tin[a] <= tin[b].
На этом условия заканчиваются.
Значит, формула работает.

ЧТД.

Мой код:
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e5;

int tin[MAXN]; int tout[MAXN];
vector <int> g[MAXN];

int T = 0;

void dfs(int curr, int parent) {
    T++; tin[curr] = T;
    for (auto to : g[curr]) {
        if (to != parent) {
            dfs(to, curr);
        }
    }
    tout[curr] = T;
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    
    int n; cin >> n;

    int root;
    for (int i = 0; i < n; i++) {
        int a; cin >> a; a--;
        if (a == -1) root = i;
        else g[a].push_back(i); g[i].push_back(a);
    }

    dfs(root, -1);

    int m; cin >> m;
    while (m--) {
        int a, b; cin >> a >> b; a--, b--;

        cout << (tin[a] <= tin[b] && tout[a] >= tout[b]) << "\n";
    }
}

 

</p>
</article>
  
  
  
  

</body>

</html>
 
